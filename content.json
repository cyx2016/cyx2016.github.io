{"meta":{"title":"cyx独立博客","subtitle":"爱生活爱编码","description":"hello,every body!~","author":"cyx","url":"http://cyx2016.github.io"},"pages":[{"title":"categories","date":"2018-04-04T08:21:50.593Z","updated":"2018-04-04T08:21:50.593Z","comments":true,"path":"categories/index.html","permalink":"http://cyx2016.github.io/categories/index.html","excerpt":"","text":"测试"},{"title":"page1","date":"2018-04-04T06:29:27.000Z","updated":"2018-04-04T06:30:15.911Z","comments":true,"path":"page1/index.html","permalink":"http://cyx2016.github.io/page1/index.html","excerpt":"","text":"测试"},{"title":"tags","date":"2018-04-04T08:21:59.413Z","updated":"2018-04-04T08:21:59.413Z","comments":true,"path":"tags/index.html","permalink":"http://cyx2016.github.io/tags/index.html","excerpt":"","text":"测试"}],"posts":[{"title":"并行理论","slug":"并行理论","date":"2018-04-23T01:18:47.000Z","updated":"2018-04-23T08:27:52.663Z","comments":true,"path":"2018/04/23/并行理论/","link":"","permalink":"http://cyx2016.github.io/2018/04/23/并行理论/","excerpt":"","text":"并行理论 并行与并发的区别 加速比定义：加速比=优化前耗时/优化后耗时 Amdahl定律 $$ 条件：n个处理器、F表示只能串行比（某些步骤只能串行的时间和优化前耗时比）、T_{n}表示n个处理器优化后耗时，T_{n}表示优化前耗时 $$ $$ T_{n}=T_{1}*（F+\\frac{1-F}{n}）$$ $$ 加速比=\\frac{T_{1}}{T_{n}}=\\frac{T_{1}}{T_{1}*（F+\\frac{1-F}{n}）} $$ $$ 当n趋近于+\\infty时 $$ $$ 加速比=\\frac{1}{F} $$ Gustafson定律 $$ 条件：n个处理器、F表示只能串行比（某些步骤只能串行的时间和优化前耗时比）、a表示串行时间、b表示并行时间 $$ $$ F=\\frac{a}{a+b} $$ $$ 加速比= \\frac{a+n*b}{a+b}=\\frac{a}{a+b}+\\frac{n*b}{a+b}=F+n*\\frac{a+b-a}{a+b}=F+n*\\left ( 1-F\\right )=n-\\left ( n-1 \\right )*F $$ 注 可以看出，由于切入角度不同，Amdahl定律的公式和Gustafson定律的公式截然不同。Gustafson定律中，如果串行比例很小，并行比例很大，那么加处理器个数，就可以获得更快的速度。而Amdahl定律却告诉我们串行比例确定时，处理器的增加是有上限的，而且到达一定程度，处理器的增加速度并不会明显有提升。 Amdahl定律强调，串行比一定是，加速比是有上限的。 Gustafson定律则前调，如果并行比足够大，那么加速比是可以随处理器的增加看成几乎是线性增长的。","categories":[{"name":"java 学习","slug":"java-学习","permalink":"http://cyx2016.github.io/categories/java-学习/"}],"tags":[]},{"title":"java-rmi学习","slug":"rmi学习","date":"2018-04-18T07:58:47.000Z","updated":"2018-04-18T07:58:35.212Z","comments":true,"path":"2018/04/18/rmi学习/","link":"","permalink":"http://cyx2016.github.io/2018/04/18/rmi学习/","excerpt":"","text":"RMI初步学习 RMI是Remote Method Invoke的缩写，是JDK提供的一个完善的、简单易用的远程调用框架，它要求客户端和服务器端都是Java程序。下面简述RMI的基本原理：如下图所示，RMI采用代理来负责客户端和服务器之间socket通信的细节。RMI框架分别为远程对象生成了客户端代理和服务器端代理，位于客户端的代理称为存根（Stub），位于服务器端的代理称为骨架（Skeleton）。 远程对象会在客户端生成存根对象。当客户端调用远程对象的方法时，实际上是调用本地存根的相应方法。然后，存根会把被访问的远程对象名、方法名以及参数编组后发送给服务器，由骨架去调用相应的远程方法并把返回值或异常返回给客户端。 基本步骤 创建远程接口，继承java.rmi.Remote接口； 创建远程类，实现远程接口； 创建服务器程序，在rmiregistry注册表中注册远程对象； 创建客户端程序，负责定位远程对象，并且调用远程方法。 代码实例 server端 定义一个接口供远程调用 package day_1; import java.rmi.Remote; public interface Warehouse extends Remote { double getPrice(String description) throws Exception; } 实现接口算法 package day_1; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; import java.util.HashMap; import java.util.Map; //服务器端接口实现 public class WarehouseImpl extends UnicastRemoteObject implements Warehouse{ private Map&lt;String, Double&gt; prices; protected WarehouseImpl() throws RemoteException { super(); prices=new HashMap&lt;&gt;(); prices.put(&quot;联想电脑G490&quot;, 2500.00); prices.put(&quot;kindle 2代&quot;, 400.00); // TODO Auto-generated constructor stub } @Override public double getPrice(String description) throws Exception { Double price=prices.get(description); return price==null ? 0 : price; } } server端开启服务 package day_1; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import javax.naming.*; public class WarehouseServer { public static void main(String[] args) throws Exception { //人工创建rmiregistry服务 LocateRegistry.createRegistry(12312); System.out.println(&quot;构造 WarehouseImpl...&quot;); WarehouseImpl centralWarehouse = new WarehouseImpl(); System.out.println(&quot;对象注册到服务器RMI注册表中...&quot;); Context namingContext = new InitialContext(); namingContext.bind(&quot;rmi://127.0.0.1:12312/Hello&quot;, centralWarehouse); System.out.println(&quot;等待客户端调用...&quot;); } } client端调用 映射服务端接口，便于调用 package day_1; import java.rmi.Remote; public interface Warehouse extends Remote { double getPrice(String description) throws Exception; } 客户端调用方法 package day_1; import java.util.Enumeration; import javax.naming.Context; import javax.naming.InitialContext; import javax.naming.NameClassPair; import javax.naming.NamingException; public class WarehouseClient { public static void main(String[] args) throws Exception { Context namingContext = new InitialContext(); System.out.println(&quot;RMI 注册表绑定&quot;); Enumeration&lt;NameClassPair&gt; e=namingContext.list(&quot;rmi://localhost:12312/&quot;); while (e.hasMoreElements()) { System.out.println(e.nextElement().getName()); } String url=&quot;rmi://127.0.0.1:12312/Hello&quot;; Warehouse centralWarehouse=(Warehouse)namingContext.lookup(url); String descr=&quot;联想电脑G490&quot;; Double price = centralWarehouse.getPrice(descr); System.out.println(descr+&quot;:&quot;+price); } } 运行截图 server端 client端 出现问题及原因 server端 原因： rmi未注册端口 后来用代码强行注册 LocateRegistry.createRegistry(12312); client端 原因： 客户端映射接口package需与服务端一致，遂改成package day_1;","categories":[{"name":"java 学习","slug":"java-学习","permalink":"http://cyx2016.github.io/categories/java-学习/"}],"tags":[]},{"title":"java-注解","slug":"注解实现理解","date":"2018-04-07T09:40:47.000Z","updated":"2018-04-07T08:56:17.136Z","comments":true,"path":"2018/04/07/注解实现理解/","link":"","permalink":"http://cyx2016.github.io/2018/04/07/注解实现理解/","excerpt":"","text":"注解实现理解 学习链接 简介 注解（Annotation）是JDK1.5引入的新特性，包含在java.lang.annotation包中，它是附加在代码中的一些元信息，将一个类的外部信息与内部成员联系起来，在编 译、运行时进行解析和使用。Java内置了一些注解（如@Override、@Deprecated等），还支持自定义注解，一些知名的框架 Struts、Hibernate、Spring都有自己实现的自定义注解，也可以自己定义注解供使用。 Annotation十分类似public、final这样的修饰符。每个Annotation具有一个名字和成员个数&gt;=0。每个Annotation的成员具有被称为name=value对的名字和值（就像javabean一样），name=value装载了Annotation的信息。 注解实现实例 注解 用途 @Target 表示该注解可以用于什么地方，可能的ElementType参数有&lt;br&gt;CONSTRUCTOR：构造器的声明&lt;br&gt;FIELD：域声明（包括enum实例）&lt;br&gt;LOCAL_VARIABLE：局部变量&lt;br&gt;METHOD：方法声明 PACKAGE：包声明&lt;br&gt;PARAMETER：参数声明 &lt;br&gt;TYPE：类、接口（包括注解类型）或enum声明 @Retention 表示需要在什么级别保存该注解信息。可选的RetentionPolicy参数包括：&lt;br&gt;SOURCE：注解将被编译器丢弃&lt;br&gt;CLASS：注解在class文件中可用，但会被VM丢弃&lt;br&gt;RUNTIME：VM将在运行期间保留注解，因此可以通过反射机制读取注解的信息。 @Document 将注解包含在Javadoc中 @Inherited 允许子类继承父类中的注解 第一步：定义注解 import java.lang.annotation.ElementType; import java.lang.annotation.Inherited; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target({ElementType.METHOD,ElementType.FIELD}) @Inherited @Retention(RetentionPolicy.RUNTIME) public @interface MyTag { String name() default &quot;车&quot;; int size() default 10; } 第二步：定义注解","categories":[{"name":"java 学习","slug":"java-学习","permalink":"http://cyx2016.github.io/categories/java-学习/"}],"tags":[]},{"title":"java-反射机制","slug":"反射机制","date":"2018-04-07T09:18:47.000Z","updated":"2018-04-07T09:04:10.083Z","comments":true,"path":"2018/04/07/反射机制/","link":"","permalink":"http://cyx2016.github.io/2018/04/07/反射机制/","excerpt":"","text":"#反射机制学习 参照学习链接 反射就是把java类中的各种成分映射成一个个的Java对象 例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象 使用详情 对象获取 第一种方式获取Class对象 Student stu1 = new Student();//这一new 产生一个Student对象，一个Class对象。 Class stuClass = stu1.getClass();//获取Class对象 System.out.println(stuClass.getName()); 第二种方式获取Class对象 Class stuClass2 = Student.class; System.out.println(stuClass == stuClass2);//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个 第三种方式获取Class对象 try { Class stuClass3 = Class.forName(&quot;fanshe.Student&quot;);//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名 System.out.println(stuClass3 == stuClass2);//判断三种方式是否获取的是同一个Class对象 } catch (ClassNotFoundException e) { e.printStackTrace(); } 构造方法获取并使用 假设对象已获取，为clazz 获取所有公有构造方法 Constructor[] conArray = clazz.getConstructors(); //输出显示 for(Constructor c : conArray){ System.out.println(c); } 获取所有构造方法 Constructor[] conArray = clazz.getDeclaredConstructors(); 获取公有、无参的构造方法 Constructor con = clazz.getConstructor(null); //null可以不写 构造方法使用 Object obj = con.newInstance(); 成员变量获取并使用 获取所有公有成员变量 Field[] fieldArray = clazz.getFields(); //输出显示 for(Constructor c : conArray){ System.out.println(c); } 同理，同构造方法一样 clazz.getDeclaredFields();//获取所有成员变量 clazz.getField(&quot;name&quot;);//获取指定成员变量，个人感觉多余 对指定对象成员变量赋值 f.set(obj, T);//f为类对象获取的成员变量，obj是实例化的对象，T是成员变量需要赋予的类型值 暴力反射，解除私有限定，同理适用于方法，不在赘述 f.setAccessible(true); 成员方法获取并调用 获取公有方法 Method[] methodArray = stuClass.getMethods(); for(Method m : methodArray){ System.out.println(m); } 获取所有方法 Method[] methodArray = stuClass.getDeclaredMethods(); 调用方法 //公有类方法调用 Method m = stuClass.getMethod(&quot;show1&quot;, String.class);//show1是方法名的字符串形式，String.class代表需要的形参 m.invoke(clazz, value); //clazz是实例对象，value是方法需要实参 //私有类方法调用 m = stuClass.getDeclaredMethod(&quot;show4&quot;, int.class); m.setAccessible(true);//解除私有限定 //有返回结果调用方法 Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参","categories":[{"name":"java 学习","slug":"java-学习","permalink":"http://cyx2016.github.io/categories/java-学习/"}],"tags":[]},{"title":"my java","slug":"my-java","date":"2018-04-07T08:18:47.000Z","updated":"2018-04-07T08:55:55.221Z","comments":true,"path":"2018/04/07/my-java/","link":"","permalink":"http://cyx2016.github.io/2018/04/07/my-java/","excerpt":"","text":"开始上传自己学习java的经历啦，学而无涯，心累。。。","categories":[{"name":"java 学习","slug":"java-学习","permalink":"http://cyx2016.github.io/categories/java-学习/"}],"tags":[]},{"title":"Hello World","slug":"index/hello-world","date":"2018-04-03T01:01:06.478Z","updated":"2018-04-03T09:22:26.401Z","comments":true,"path":"2018/04/03/index/hello-world/","link":"","permalink":"http://cyx2016.github.io/2018/04/03/index/hello-world/","excerpt":"","text":"技术小白玩博客 哈哈，博客新建，欢迎浏览，努力提升技术，不想看博客技术的，下面忽略 技术来源 额，主题冲突了，算了，下次再看，毕竟一口吃不成胖子","categories":[],"tags":[]},{"title":"blog-source","slug":"blogit/blog-source-1","date":"2018-04-02T07:01:02.000Z","updated":"2018-04-03T09:03:02.097Z","comments":true,"path":"2018/04/02/blogit/blog-source-1/","link":"","permalink":"http://cyx2016.github.io/2018/04/02/blogit/blog-source-1/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"blog","slug":"blog","permalink":"http://cyx2016.github.io/categories/blog/"}],"tags":[]}]}